# ===============================
# CONFIGURACIÓN DE LA BASE DE DATOS
# ===============================
# Se recomienda usar variables de entorno para las credenciales en producción.
# Docker Compose inyectará estos valores desde tu archivo .env
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://db:5432/shopchop}
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:shopchop}
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:example}
spring.datasource.driver-class-name=org.postgresql.Driver

# ===============================
# CONFIGURACIÓN DE JPA / HIBERNATE
# ===============================
# "update": Hibernate actualiza el esquema de la DB en función de tus entidades.
# Utiliza "validate" en producción si usas scripts de migración (Flyway/Liquibase).
spring.jpa.hibernate.ddl-auto=update

# Muestra las sentencias SQL que Hibernate ejecuta en la consola.
spring.jpa.show-sql=true

# Utiliza el dialecto específico de PostgreSQL para optimizar las queries.
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ===============================
# CONFIGURACIÓN DEL SERVIDOR WEB
# ===============================
# El puerto en el que se ejecutará tu aplicación.
server.port=${SERVER_PORT:8080}

# ===============================
# CONFIGURACIÓN DE INICIALIZACIÓN DE DATOS (OPCIONAL)
# ===============================
# Para cargar datos de prueba desde un archivo data.sql al iniciar la app.
# spring.sql.init.mode=always

jwt.secret=be633561f654ccef6942a96f646fa1281d7dfd694bdfce029dd7149685b6fb58
jwt.expiration=840000